#!/usr/bin/env node

/**
 * termcoin
 * Copyright (c) 2013, Christopher Jeffrey
 * https://github.com/chjj/termcoin
 */

// bitcoind -server -daemon -rpcuser=bitcoinrpc -rpcpassword=foobar -rpcport=8332 -rpcallowip=127.0.0.1
// termcoin http://bitcoinrpc:foobar@localhost:8332/
// https://github.com/bitcoin/bitcoin/blob/master/src/rpcserver.cpp
// https://github.com/bitcoin/bitcoin/blob/master/src/rpcrawtransaction.cpp
// https://github.com/bitcoin/bitcoin/blob/master/src/rpcwallet.cpp
// http://blockchain.info/api/json_rpc_api

/**
 * Modules
 */

var fs = require('fs')
  , url = require('url')
  , util = require('util')
  , blessed = require('blessed')
  , path = require('path')
  , cp = require('child_process')
  , config
  , opt;

var now = Date.now();

var platform
  , client;

var coins = {
  bitcoin: {
    name: 'bitcoin',
    daemon: 'bitcoind',
    config: process.env.HOME + '/.bitcoin/bitcoin.conf',
    wallet: process.env.HOME + '/.bitcoin/wallet.dat'
  },
  litecoin: {
    name: 'litecoin',
    daemon: 'litecoind',
    config: process.env.HOME + '/.litecoin/litecoin.conf',
    wallet: process.env.HOME + '/.litecoin/wallet.dat'
  },
  dogecoin: {
    name: 'dogecoin',
    daemon: 'dogecoind',
    config: process.env.HOME + '/.dogecoin/dogecoin.conf',
    wallet: process.env.HOME + '/.dogecoin/wallet.dat'
  },
  namecoin: {
    name: 'namecoin',
    daemon: 'namecoind',
    config: process.env.HOME + '/.namecoin/namecoin.conf',
    wallet: process.env.HOME + '/.namecoin/wallet.dat'
  }
};

function readConf() {
  var data;

  try {
    data = fs.readFileSync(platform.config, 'utf8');
  } catch (e) {
    return;
  }

  data = data.trim().split(/(\r?\n)+/);

  return data.reduce(function(out, line) {
    var parts = line.trim().split(/\s*=\s*/)
      , key = parts[0]
      , val = parts[1];

    out[key] = val;

    return out;
  }, {});
}

function getStats(callback) {
  return getTotalBalance(function(err, balances) {
    if (err) return callback(err);
    return getAccounts(function(err, accounts) {
      if (err) return callback(err);
      return getTransactions(function(err, transactions) {
        if (err) return callback(err);
        return getAddresses(accounts, function(err, addresses) {
          if (err) return callback(err);
          return getInfo(function(err, info) {
            if (err) return callback(err);

            if (opt.mock && !transactions.length) {
              for (var i = 0; i < 10; i++) {
                transactions.push({
                  txid: i + 1000,
                  time: now / 1000 | 0,
                  category: 'send',
                  amount: 2.23,
                  fee: 0.005,
                  confirmations: 23,
                  otheraccount: '1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg',
                  message: 'hello',
                  to: 'hello'
                });
              }
            }

            return callback(null, {
              balances: balances,
              accounts: accounts,
              transactions: transactions,
              addresses: addresses,
              info: info
            });
          });
        });
      });
    });
  });
}

// Ridiculous workaround:
function getAddresses(accounts, callback) {
  if (opt.host) return callback(null, []);

  if (!callback) {
    callback = accounts;
    accounts = null;
  }

  var wallet = fs.readFileSync(platform.wallet, 'utf8')
    , m = wallet.match(/[a-zA-Z0-9]{34}/g)
    , results = [];

  // XXX Slower, but better
  var s = wallet, ma = [];
  do {
    m = /^[a-zA-Z0-9]{34}/g.exec(s);
    if (m) ma.push(m[0]);
  } while (s = s.substring(1));
  if (!ma.length) ma = null;
  m = ma;
  // END

  if (!m) return callback(null, results);

  return forEach(m, function(address, next) {
    return client.call('getaccount', [address], function(err, name) {
      if (err) return next();
      results.push({
        name: name,
        address: address
      });
      return next();
    });
  }, function() {
    if (accounts) {
      // Exclude the user's addresses.
      var add = Object.keys(accounts).map(function(key) {
        return accounts[key].address;
      });
      results = results.filter(function(item) {
        return add.indexOf(item.address) === -1;
      });
    }
    return callback(null, results);
  });
}

function forEach(obj, iter, done) {
  var pending = obj.length;
  function next() {
    --pending || done();
  }
  obj.forEach(function(item, i) {
    iter(item, next, i);
  });
}

function getAccounts(callback) {
  var results = {};
  return client.call('listaccounts', function(err, accounts) {
    if (err) return callback(err);
    return forEach(Object.keys(accounts), function(name, next) {
      return client.call('getaccountaddress', [name], function(err, address) {
        if (err) return next();
        results[address] = {
          name: name,
          address: address,
          balance: accounts[name]
        };
        return next();
      });
    }, function() {
      return callback(null, results);
    });
  });
}

function getProgress(callback) {
  return client.call('getblockcount', function(err, blocks) {
    if (err) return callback(err);
    return client.call('getconnectioncount', function(err, connections) {
      if (err) return callback(err);
      return callback(null, {
        blocks: blocks,
        connections: connections
      });
    });
  });
}

function getInfo(callback) {
  return client.call('getinfo', callback);
}

function getTransactions(callback) {
  return client.call('listtransactions', ['*', 1000], callback);
}

function getTotalBalance(callback) {
  return client.call('getbalance', ['*', 6], function(err, balance) {
    if (err) return callback(err);
    return client.call('getbalance', ['*', 0], function(err, unconfirmed) {
      if (err) return callback(err);
      unconfirmed -= balance;
      return callback(null, {
        balance: balance,
        unconfirmed: unconfirmed
      });
    });
  });
}

function createAddress(name, callback) {
  //return client.call('setaccount', [address, value], function(err) {
  //return client.call('getaccountaddress', [name], callback);
  return client.call('getnewaddress', [name], callback);
}

function backupWallet(path, callback) {
  return client.call('backupwallet', [path], callback);
}

function send(address, amount, callback) {
  return client.call('sendtoaddress', [address, amount], callback);
}

function move(from, to, amount, callback) {
  return client.call('move', [from, to, amount], callback);
}

function startServer(callback) {
  return callback();
  if (opt.host) return callback();
  console.log('Stopping existing server.');
  return cp.execFile(platform.daemon, ['stop'], function(err) {
    if (err) return callback(err);
    console.log('Starting new server.');
    var args = [
      '-server',
      '-daemon',
      '-rpcuser=' + config.rpcuser,
      '-rpcpassword=' + config.rpcpassword,
      '-rpcport=' + config.rpcport,
      '-rpcallowip=127.0.0.1'
    ];
    return cp.execFile(platform.daemon, args, function(err) {
      if (err) return callback(err);
      return callback();
    });
  });
}

function start(stats, callback) {
  var screen = blessed.screen({
    autoPadding: true,
    smartCSR: true
  });

  var target;

  var bar = blessed.listbar({
    parent: screen,
    top: 0,
    left: 0,
    right: 0,
    height: 1,
    keys: true,
    mouse: true,
    autoCommandKeys: true,
    style: {
      bg: 'black',
      item: {
        bg: 'blue'
      },
      selected: {
        bg: 'lightblue'
      },
      prefix: {
        fg: 'green'
      }
    }
  });

  var sep = blessed.line({
    parent: screen,
    top: 1,
    left: 0,
    right: 0,
    orientation: 'horizontal'
  });

  var tabs = {};

  ['overview',
   'send',
   'receive',
   'transactions',
   'addresses',
   'miner',
   'debug'].forEach(function(name) {
    var tab = tabs[name] = blessed.box({
      top: 2,
      left: 0,
      right: 0,
      bottom: 0,
      scrollable: true,
      keys: true,
      vi: true,
      alwaysScroll: true,
      scrollbar: {
        ch: ' '
      },
      style: {
        scrollbar: {
          inverse: true
        }
      }
    });

    bar.addItem({
      text: name,
      callback: function() {
        if (target) target.detach();
        screen.append(tab);
        tab.focus();
        target = tab;
        screen.render();
      }
    });
  });

  bar.commands[0].callback();

  /**
   * Overview
   */

  tabs.overview._.wallet = blessed.text({
    parent: tabs.overview,
    top: 0,
    left: 3,
    height: 'shrink',
    width: '40%',
    label: ' {blue-fg}Wallet{/blue-fg} ',
    tags: true,
    border: {
      type: 'line'
    },
    content: 'No balance.',
    tags: true
  });

  tabs.overview._.transactions = blessed.text({
    parent: tabs.overview,
    top: 0,
    right: 3,
    height: 'shrink',
    width: '40%',
    label: ' {blue-fg}Transactions{/blue-fg} ',
    tags: true,
    border: {
      type: 'line'
    },
    content: 'No transactions.',
    tags: true
  });

  tabs.overview._.data = blessed.box({
    parent: tabs.overview,
    bottom: 0,
    left: 3,
    // XXX Fix in blessed:
    // height: 'shrink',
    height: 4,
    width: '40%',
    label: ' {blue-fg}Data{/blue-fg} ',
    tags: true,
    border: 'line',
    content: 'Loading... ',
    style: {
      fg: 'lightblack',
      bar: {
        bg: 'blue'
      }
    }
  });

  tabs.overview._.bar = blessed.progressbar({
    parent: tabs.overview._.data,
    top: 1,
    left: 0,
    right: 0,
    height: 'shrink',
    orientation: 'horizontal',
    filled: 0,
    ch: '|',
    tags: true,
    content: 'Syncing... ',
    style: {
      fg: 'lightblack',
      bar: {
        bg: 'blue'
      }
    }
  });

  (function self() {
    return getProgress(function(err, data) {
      if (data) {
        //tabs.overview._.bar.progress(1);
        tabs.overview._.data.setContent('Connections: ' + data.connections);
        tabs.overview._.bar.content = 'Blocks: ' + data.blocks + ' ';
        screen.render();
      }
      setTimeout(self, 1000);
    });
  })();

  tabs.overview._.backup = blessed.button({
    parent: tabs.overview,
    bottom: 0,
    right: 3,
    height: 'shrink',
    width: 'shrink',
    content: 'Backup Wallet',
    tags: true,
    border: 'line',
    mouse: true,
    keys: true,
    style: {
      fg: 'default',
      bg: 'blue',
      hover: {
        bg: 'lightblack'
      },
      border: {
        bg: 'blue'
      }
    }
  });

  tabs.overview._.backup.on('press', function() {
    // TODO: Add prompt for this.
    // TODO: Add global prompt anyway.
    backupWallet(process.env.HOME + '/wallet.dat.bak', function(err) {
      if (err) return msg.error(err.messsage);
      msg.display('Wallet successfully backed up.');
      screen.render();
    });
  });

  /**
   * Send
   */

  tabs.send.on('focus', function() {
    tabs.send._.form.focus();
  });

  tabs.send._.form = blessed.form({
    parent: tabs.send,
    top: 0,
    left: 1,
    right: 1,
    //height: 9,
    // Fixed in blessed:
    height: 'shrink',
    keys: true,
    mouse: true,
    label: ' {blue-fg}Send{/blue-fg} ',
    border: 'line',
    tags: true
  });

  tabs.send._.ttext = blessed.text({
    parent: tabs.send._.form,
    top: 0,
    left: 0,
    height: 1,
    content: 'Pay {underline}T{/underline}o:',
    tags: true
  });

  tabs.send._.address = blessed.textbox({
    parent: tabs.send._.form,
    name: 'address',
    inputOnFocus: true,
    top: 0,
    left: 9,
    right: 1,
    height: 1,
    style: {
      bg: 'black',
      focus: {
        bg: 'blue'
      },
      hover: {
        bg: 'blue'
      }
    }
  });

  tabs.send._.ltext = blessed.text({
    parent: tabs.send._.form,
    top: 2,
    left: 0,
    height: 1,
    content: ' {underline}L{/underline}abel:',
    tags: true
  });

  tabs.send._.label = blessed.textbox({
    parent: tabs.send._.form,
    name: 'label',
    inputOnFocus: true,
    top: 2,
    left: 9,
    right: 1,
    height: 1,
    style: {
      bg: 'black',
      focus: {
        bg: 'blue'
      },
      hover: {
        bg: 'blue'
      }
    }
  });

  tabs.send._.mtext = blessed.text({
    parent: tabs.send._.form,
    top: 4,
    left: 0,
    height: 1,
    content: 'A{underline}m{/underline}ount:',
    tags: true
  });

  tabs.send._.amount = blessed.textbox({
    parent: tabs.send._.form,
    name: 'amount',
    inputOnFocus: true,
    top: 4,
    left: 9,
    right: 1,
    height: 1,
    style: {
      bg: 'black',
      focus: {
        bg: 'blue'
      },
      hover: {
        bg: 'blue'
      }
    }
  });

  tabs.send._.submit = blessed.button({
    parent: tabs.send._.form,
    name: 'submit',
    top: 6,
    right: 1,
    height: 1,
    width: 'shrink',
    content: ' Send ',
    style: {
      bg: 'black',
      focus: {
        bg: 'blue'
      },
      hover: {
        bg: 'blue'
      }
    }
  });

  tabs.send._.submit.on('press', function() {
    tabs.send._.form.submit();
  });

  tabs.send._.form.on('submit', function(data) {
    var alias = stats.addresses.reduce(function(out, item) {
      out[item.name] = item;
      return out;
    }, {});

    // XXX Own
    alias = Object.keys(stats.accounts).reduce(function(out, key) {
      out[stats.accounts[key].name] = stats.accounts[key];
      return out;
    }, alias);

    if (data.address && alias[data.address]) {
      data.address = alias[data.address].address;
    }

    // XXX Own
    /*
    var method;
    if (stats.accounts[data.address]) {
      method = move;
    } else {
      method = send;
    }
    */

    send(data.address, +data.amount, function(err, result) {
      if (err) return msg.error(err.message);
      if (!result || !Object.keys(result).length) {
        return msg.error('Transaction not completed.');
      }
      msg.display('Transaction completed successfully: ' + result.txid + '.');
    });
  });

  tabs.send._.picker = blessed.list({
    parent: tabs.send,
    top: 'center',
    left: 'center',
    height: '50%',
    width: '70%',
    border: 'line',
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    hidden: true,
    style: {
      scrollbar: {
        inverse: true
      },
      selected: {
        bg: 'blue'
      },
      item: {
        hover: {
          bg: 'blue'
        }
      }
    },
    scrollbar: {
      ch: ' '
    }
  });

  tabs.send._.address.key('C-e', function() {
    var addresses = stats.addresses.map(function(item) {
      return item.name || item.address;
    });

    // XXX Own
    var accounts = Object.keys(stats.accounts).map(function(key) {
      var item = stats.accounts[key];
      return item.name || item.address;
    });
    addresses = addresses.concat(accounts);

    tabs.send._.picker.setItems(addresses);

    tabs.send._.picker.pick(function(err, value) {
      if (err) return;
      tabs.send._.address.setValue(value);
      screen.render();
    });
  });

  /**
   * Receive
   */

  tabs.receive.on('focus', function() {
    tabs.receive._.list.focus();
  });

  tabs.receive._.list = blessed.list({
    parent: tabs.receive,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    style: {
      scrollbar: {
        inverse: true
      },
      selected: {
        bg: 'blue'
      },
      item: {
        hover: {
          bg: 'blue'
        }
      }
    },
    scrollbar: {
      ch: ' '
    }
  });

  tabs.receive._.prompt = blessed.prompt({
    parent: tabs.receive,
    top: 'center',
    left: 'center',
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    content: 'Label:',
    border: 'line',
    hidden: true
  });

  tabs.receive._.question = blessed.question({
    parent: tabs.receive,
    top: 'center',
    left: 'center',
    width: 'shrink',
    height: 'shrink',
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    content: 'Label:',
    border: 'line',
    hidden: true
  });

  tabs.receive._.list.key('d', function() {
    var list = tabs.receive._.list
      , el = list.items[list.selected];

    var parts = el.getText().trim().split(/\s+/)
      , label = parts[0]
      , address = parts[1];

    tabs.receive._.question.ask('Are you sure you want to delete this?', function(err, value) {
      if (err) return msg.error(err.message);
      if (!value) return screen.render();
      return client.call('setaccount', [address], function(err) {
        if (err) return msg.error(err.message);
        text = 'Deleted address: {blue-fg}' + address + '{/blue-fg}';
        msg.display(text);
        screen.render();
        refresh();
      });
    });
  });

  tabs.receive._.list.on('select', function(el, index) {
    var parts = el.getText().trim().split(/\s+/)
      , label = parts[0]
      , address = parts[1]
      , text;

    if (label === 'new') {
      text = 'Label for new address:';
      return tabs.receive._.prompt.type(text, '', function(err, value) {
        if (err) return msg.error(err.message);
        return createAddress(value, function(err, address) {
          if (err) return msg.error(err.message);
          text = 'Created address: {blue-fg}' + address + '{/blue-fg}';
          msg.display(text);
          screen.render();
          refresh();
        });
      });
    }

    text = 'Label for {blue-fg}' + address + '{/blue-fg}:';
    return tabs.receive._.prompt.type(text, '', function(err, value) {
      if (err) return msg.error(err.message);
      if (!value) return;
      return client.call('setaccount', [address, value], function(err) {
        if (err) return msg.error(err.message);
        text = 'Edited label: {blue-fg}' + label + '->' + value + '{/blue-fg}';
        msg.display(text);
        screen.render();
        refresh();
      });
    });
  });


  /**
   * Transactions
   */

  tabs.transactions.on('focus', function() {
    tabs.transactions._.list.focus();
  });

  tabs.transactions._.list = blessed.list({
    parent: tabs.transactions,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    style: {
      scrollbar: {
        inverse: true
      },
      selected: {
        bg: 'blue'
      },
      item: {
        hover: {
          bg: 'blue'
        }
      }
    },
    scrollbar: {
      ch: ' '
    }
  });

  tabs.transactions._.msg = blessed.message({
    parent: tabs.transactions,

    // Fixed in blessed.
    top: 'center',
    left: 'center',
    height: 'shrink',
    width: 'shrink',

    //top: 2,
    //left: 4,
    //right: 4,
    //bottom: 2,

    scrollable: true,
    alwaysScroll: true,
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    hidden: true,
    border: 'line',
    scrollbar: {
      ch: ' '
    },
    style: {
      scrollbar: {
        bg: 'blue'
      }
    }
  });

  tabs.transactions._.list.on('select', function(el, index) {
    var parts = el.getText().trim().split(/\s*\|\s*/)
      , id = parts[0];

    var getTransaction = function(id, callback) {
      if (opt.mock) {
        return callback(null, {
          txid: id,
          time: now / 1000 | 0,
          category: 'send',
          amount: 2.23,
          fee: 0.005,
          confirmations: 23,
          otheraccount: '1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg',
          message: 'hello',
          to: 'hello'
        });
      }
      return client.call('gettransaction', [id], callback);
    };

    return getTransaction(id, function(err, transaction) {
      if (err) return;
      var text = inspect(transaction);
      tabs.transactions._.msg.display(text, -1);
    });
  });

  /**
   * Addresses
   */

  tabs.addresses.on('focus', function() {
    tabs.addresses._.list.focus();
  });

  tabs.addresses._.list = blessed.list({
    parent: tabs.addresses,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    style: {
      scrollbar: {
        inverse: true
      },
      selected: {
        bg: 'blue'
      },
      item: {
        hover: {
          bg: 'blue'
        }
      }
    },
    scrollbar: {
      ch: ' '
    }
  });

  tabs.addresses._.prompt = blessed.prompt({
    parent: tabs.addresses,
    top: 'center',
    left: 'center',
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    content: 'Label:',
    border: 'line',
    hidden: true
  });

  tabs.addresses._.question = blessed.question({
    parent: tabs.addresses,
    top: 'center',
    left: 'center',
    width: 'shrink',
    height: 'shrink',
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    content: 'Label:',
    border: 'line',
    hidden: true
  });

  tabs.addresses._.list.key('d', function() {
    var list = tabs.addresses._.list
      , el = list.items[list.selected];

    var parts = el.getText().trim().split(/\s+/)
      , label = parts[0]
      , address = parts[1];

    tabs.addresses._.question.ask('Are you sure you want to delete this?', function(err, value) {
      if (err) return msg.error(err.message);
      if (!value) return screen.render();
      return client.call('setaccount', [address], function(err) {
        if (err) return msg.error(err.message);
        text = 'Deleted address: {blue-fg}' + address + '{/blue-fg}';
        msg.display(text);
        screen.render();
        refresh();
      });
    });
  });

  tabs.addresses._.list.on('select', function(el, index) {
    var parts = el.getText().trim().split(/\s+/)
      , label = parts[0]
      , address = parts[1]
      , text;

    if (label === 'new') {
      text = 'Label for new address:';
      return tabs.addresses._.prompt.type(text, '', function(err, label) {
        if (err) return msg.error(err.message);
        if (!label) return;
        text = 'Address:';
        return tabs.addresses._.prompt.type(text, '', function(err, address) {
          if (err) return msg.error(err.message);
          if (!address) return;
          return client.call('setaccount', [address, label], function(err) {
            if (err) return msg.error(err.message);
            text = 'Created address: {blue-fg}' + label + '{/blue-fg}';
            msg.display(text);
            screen.render();
            refresh();
          });
        });
      });
    }

    text = 'Label for {blue-fg}' + address + '{/blue-fg}:';
    return tabs.addresses._.prompt.type(text, '', function(err, value) {
      if (err) return msg.error(err.message);
      if (!value) return;
      return client.call('setaccount', [address, value], function(err) {
        if (err) return msg.error(err.message);
        text = 'Edited label: {blue-fg}' + label + '->' + value + '{/blue-fg}';
        msg.display(text);
        screen.render();
        refresh();
      });
    });
  });

  /**
   * Debug
   */

  tabs.debug._.data = blessed.text({
    parent: tabs.debug,
    top: 0,
    left: 3,
    height: 'shrink',
    width: 'shrink',
    content: '',
    tags: true
  });

  tabs.debug.key(['f5', 'r'], function() {
    refresh();
  });

  /**
   * Loader
   */

  var loader = blessed.loading({
    parent: screen,
    top: 'center',
    left: 'center',
    height: 3,
    align: 'center',
    width: '50%',
    tags: true,
    hidden: true,
    border: 'line'
  });

  /**
   * Message
   */

  var msg = blessed.message({
    parent: screen,
    top: 'center',
    left: 'center',
    // Fixed in blessed:
    // height: '50%',
    height: 'shrink',
    width: '50%',
    align: 'center',
    tags: true,
    hidden: true,
    border: 'line'
  });

  msg.display('Welcome to {blue-fg}termcoin{/blue-fg}!');

  function refresh(callback, noLoad) {
    if (!noLoad) loader.load('Loading...');
    return getStats(function(err, stats_) {
      if (err) {
        if (!noLoad) loader.stop();
        return;
      }

      stats = stats_;

      var items;

      // Wallet
      tabs.overview._.wallet.setContent(
        '{blue-fg}Balance{blue-fg}:     {yellow-fg}'
        + stats.balances.balance.toFixed(8) + '{/yellow-fg}\n'
        + '{red-fg}Unconfirmed{red-fg}: {yellow-fg}'
        + stats.balances.unconfirmed.toFixed(8) + '{/red-fg}');

      // Accounts
      var accounts = Object.keys(stats.accounts).map(function(key) {
        return stats.accounts[key];
      });
      accounts = asort(accounts);
      items = accounts.reduce(function(out, account) {
        var w = screen.width;
        var name = account.name || '[none]';
        var sp = Array(w - (account.address.length + name.length) + 1).join(' ');
        out.push('{blue-fg}' + name + '{/blue-fg}'
          + sp + '{green-fg}' + account.address + '{/green-fg}');
        return out;
      }, []);
      items.unshift('new');
      tabs.receive._.list.setItems(items);

      // Transactions
      items = stats.transactions.reduce(function(out, t) {
        // ID | Date | Type | Address | Amount
        var s = t.txid
          + ' | '
          + '{black-fg}' + new Date(t.time * 1000).toISOString() + '{/black-fg}'
          + ' | '
          + '{blue-fg}' + t.category + '{/blue-fg}'
          + ' | '
          + '{green-fg}' + (t.otheraccount || t.address || t.account) + '{/green-fg}'
          + ' | '
          + '{yellow-fg}' + t.amount + '{/yellow-fg}'
          + (t.fee ? '({red-fg}-' + t.fee + '{/red-fg})' : '');
        out.push(s);
        return out;
      }, []);
      tabs.transactions._.list.setItems(items);

      tabs.overview._.transactions.setContent(items.slice(0, 3).join('\n'));

      // Addresses
      var addresses = asort(stats.addresses);
      items = addresses.reduce(function(out, account) {
        var w = screen.width;
        var name = account.name || '[none]';
        var sp = Array(w - (account.address.length + name.length) + 1).join(' ');
        out.push('{blue-fg}' + name + '{/blue-fg}'
          + sp + '{green-fg}' + account.address + '{/green-fg}');
        return out;
      }, []);
      items.unshift('new');
      tabs.addresses._.list.setItems(items);

      // Debug
      tabs.debug._.data.setContent(inspect(stats));

      screen.render();

      if (!noLoad) loader.stop();
      if (callback) callback();
    });
  }

  (function self() {
    return refresh(function() {
      return setTimeout(self, 10 * 1000);
    }, true);
  })();

  screen.key(['C-c', 'q'], function() {
    if (!opt.host) {
      //client.call('stop', function() {
      return callback();
      return;
    }
    return callback();
  });

  screen.render();
}

function parseArg(argv) {
  var argv = argv.slice(2)
    , options = {}
    , files = [];

  function getarg() {
    var arg = argv.shift();

    if (arg.indexOf('--') === 0) {
      // e.g. --opt
      arg = arg.split('=');
      if (arg.length > 1) {
        // e.g. --opt=val
        argv.unshift(arg.slice(1).join('='));
      }
      arg = arg[0];
    } else if (arg[0] === '-') {
      if (arg.length > 2) {
        // e.g. -abc
        argv = arg.substring(1).split('').map(function(ch) {
          return '-' + ch;
        }).concat(argv);
        arg = argv.shift();
      } else {
        // e.g. -a
      }
    } else {
      // e.g. foo
    }

    return arg;
  }

  while (argv.length) {
    arg = getarg();
    switch (arg) {
      case '-c':
      case '--currency':
        platform = coins[argv.shift()];
        if (!platform) throw new Error('Unrecognized currency.');
        break;
      case '-s':
      case '--server':
        options.server = url.parse(argv.shift());
        if (options.server.auth) {
          var parts = options.server.auth.split(':');
          options.server.user = parts[0];
          options.server.password = parts[1] || '';
        }
        options.host = options.server.hostname;
        options.port = +options.server.port;
        options.user = options.server.user;
        options.password = options.server.password;
        options.ssl = options.server.protocol === 'https:';
        break;
      case '-h':
      case '--help':
        return help();
      case '--debug':
        options.debug = true;
        break;
      case '--mock':
        options.mock = true;
        break;
      default:
        if (~arg.indexOf('://')) {
          argv.unshift(arg);
          argv.unshift('-s');
        } else {
          files.push(arg);
        }
        break;
    }
  }

  if (!platform) {
    platform = coins.bitcoin;
  }

  return options;
}

function help() {
  console.log('termcoin - a text ui for bitcoin/litecoin/dogecoin/etc.');
  return process.exit(0);
}

function main(argv, callback) {
  opt = parseArg(argv);
  config = readConf();

  config.rpchost = opt.host || config.rpchost || 'localhost';
  config.rpcport = opt.port || config.rpcport || 8332;
  config.rpcuser = opt.user || config.rpcuser || 'bitcoinrpc';
  config.rpcpassword = opt.password || config.rpcpassword || 'foobar';
  config.rpcssl = opt.ssl || config.rpcssl || false;

  client = new Client({
    host: config.rpchost,
    port: config.rpcport,
    user: config.rpcuser,
    pass: config.rpcpassword,
    ssl: config.rpcssl
  });

  return startServer(function(err) {
    if (err) return callback(err);
    return getStats(function(err, stats) {
      if (err) return callback(err);
      return start(stats, function(err) {
        if (err) return callback(err);
        return callback();
      });
    });
  });
}

/**
 * Client
 */

function Client(options) {
  this.options = options;
  this._id = 0;
}

Client.prototype.call = function(method, params, callback) {
  if (!callback) {
    callback = params;
    params = [];
  }
  return this._call({ method: method, params: params }, callback);
};

Client.prototype._call = function(call, options, callback) {
  var self = this;

  if (!callback) {
    callback = options;
    options = {};
  }

  if (Array.isArray(call)) {
    options.body = call.map(function(item) {
      return {
        id: self._id++,
        method: item.method,
        params: item.params
      };
    });
  } else {
    options.body = {
      id: self._id++,
      method: call.method,
      params: call.params
    };
  }

  return this.request(options, callback);
};

Client.prototype.request = function(options, callback) {
  var self = this
    , path = options.path || '/'
    , body = options.body || {}
    , method = options.method || 'POST'
    , cb = callback;

  if (typeof callback !== 'function') {
    callback = function() {};
  }

  options = {
    method: method,
    uri: (this.options.ssl ? 'https' : 'http')
      + '://'
      + this.options.user
      + ':'
      + this.options.pass
      + '@'
      + this.options.host
      + ':'
      + this.options.port
      + path,
    json: body
  };

  return request(options, function(err, res, body) {
    if (err) {
      return callback(new Error(err));
    }

    if (res.statusCode === 403 || res.statusCode === 401) {
      return callback(new Error('Forbidden.'));
    }

    if (res.statusCode === 404) {
      return callback(new Error('Not found.'));
    }

    try {
      if (typeof body === 'string') {
        body = JSON.parse(body);
      }
    } catch (e) {
      e.message += '\nStatus code: ' + res.statusCode + '.';
      e.message += '\nJSON: ' + body;
      return callback(e);
    }

    if (!body) {
      return callback(new Error('No body.'));
    }

    if (body.error) {
      err = new Error(body.error.message);
      err.code = body.error.code;
      return callback(err);
    }

    return callback(null, body.result);
  });
};

/**
 * Helpers
 */

function inspect(obj) {
  return typeof obj !== 'string'
    ? util.inspect(obj, false, 6, true)
    : obj;
}

function asort(obj) {
  return obj.sort(function(a, b) {
    a = a.name.toLowerCase();
    b = b.name.toLowerCase();

    if (a[0] === '.' && b[0] === '.') {
      a = a[1];
      b = b[1];
    } else {
      a = a[0];
      b = b[0];
    }

    return a > b ? 1 : (a < b ? -1 : 0);
  });
}

var http = require('http');
var StringDecoder = require('string_decoder').StringDecoder;

function request(options, callback) {
  if (typeof options === 'string' || options.hostname) {
    options = { uri: options };
  }

  var uri = options.uri || options.url
    , body = options.json
        ? JSON.stringify(options.json)
        : options.body || '';

  if (typeof uri !== 'object') {
    uri = url.parse(uri);
  }

  if (options.qs) {
    var query = uri.query ? qs.parse(uri.query) : {};
    Object.keys(options.qs).forEach(function(key) {
      query[key] = options.qs[key];
    });
    uri.path = uri.pathname + '?' + qs.stringify(query);
  }

  var protocol = uri.prototype === 'https:'
    ? require('https')
    : http;

  options.method = options.method || (body ? 'POST' : 'GET');
  options.method = options.method.toUpperCase();
  options.headers = options.headers || {};

  if (options.json) {
    options.headers['Content-Type'] = 'application/json; charset=utf-8';
    options.headers['Accept'] = 'application/json';
  }

  if (options.method !== 'GET' && options.method !== 'HEAD') {
    options.headers['Content-Length'] = Buffer.byteLength(body);
  }

  var opt = {
    auth: uri.auth,
    host: uri.hostname,
    port: uri.port || (protocol === http ? 80 : 443),
    path: uri.path,
    method: options.method,
    headers: options.headers
  };

  var req = protocol.request(opt);

  req.on('response', function(res) {
    var decoder = new StringDecoder('utf8')
      , done = false
      , body = '';

    function end() {
      if (done) return;
      done = true;
      res.body = body;
      if (options.json) {
        try {
          body = JSON.parse(body);
        } catch (e) {
          ;
        }
      }
      callback(null, res, body);
      res.socket.removeListener('end', end);
    }

    res.on('data', function(data) {
      body += decoder.write(data);
    });

    res.on('error', function(err) {
      res.destroy();
      callback(err);
    });

    res.on('end', end);

    // An agent socket's `end` sometimes
    // wont be emitted on the response.
    res.socket.on('end', end);
  });

  req.end(body);
}

/**
 * Execute
 */

if (!module.parent) {
  process.title = 'termcoin';
  main(process.argv.slice(), function(err) {
    if (err) throw err;
    return process.exit(0);
  });
} else {
  module.exports = main;
}
